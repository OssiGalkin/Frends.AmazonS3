using Amazon;
using Amazon.S3;
using Amazon.S3.Model;
using Frends.AmazonS3.UploadObject.Definitions;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.AmazonS3.UploadObject;

/// <summary>
/// Amazon S3 Task.
/// </summary>
public class AmazonS3
{
    /// <summary>
    /// Upload objects to AWS S3 Bucket.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AmazonS3.UploadObject)
    /// </summary>
    /// <param name="connection">Connection parameters</param>
    /// <param name="input">Input parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool success, List&lt;string&gt; uploadedObjects, string debugLog } </returns>
    public static async Task<Result> UploadObject([PropertyTab] Connection connection, [PropertyTab] Input input, CancellationToken cancellationToken)
    {

        if (!Directory.Exists(input.FilePath)) throw new ArgumentException(@"Source directory not found. ", input.FilePath);

        var localRoot = new DirectoryInfo(input.FilePath);

        // If filemask is not set, get all files.
        var filesToCopy = localRoot.GetFiles(
            input.FileMask ?? "*",
            connection.UploadFromCurrentDirectoryOnly ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories);

        if (connection.ThrowErrorIfNoMatch && filesToCopy.Length < 1)
            throw new Exception($"No files match the filemask '{input.FileMask ?? "*"}' within supplied path.");

        var result = new List<string>();
        var sw = new StringWriter();

        try
        {
            AWSConfigs.LoggingConfig.LogTo = LoggingOptions.None; 
            Console.SetOut(sw);

            foreach (var file in filesToCopy)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (file.FullName.Split(Path.DirectorySeparatorChar).Length > input.FilePath.Split(Path.DirectorySeparatorChar).Length && connection.PreserveFolderStructure)
                {
                    var subfolders = file.FullName.Replace(file.Name, "").Replace(input.FilePath.Replace(file.Name, ""), "").Replace(Path.DirectorySeparatorChar, '/');

                    if (subfolders.StartsWith("/"))
                        subfolders = subfolders.Remove(0, 1);

                    var fullPath = input.S3Directory + subfolders + file.Name;

                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedURL)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input.PartSize, fullPath, cancellationToken);
                        else
                            await UploadFileToS3(file, connection, fullPath, input, cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? fullPath : file.FullName);
                }
                else
                {
                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedURL)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input.PartSize, input.S3Directory + file.Name, cancellationToken);
                        else
                            await UploadFileToS3(file, connection, input.S3Directory + file.Name, input, cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? input.S3Directory + file.Name : file.FullName);
                }

                if (connection.DeleteSource) DeleteSourceFile(file.FullName);

                // Each file require their own presigned URL so no point to loop more than first file.
                if (connection.AuthenticationMethod == AuthenticationMethod.PreSignedURL) break;
            }

            return new Result(true, result, sw.ToString());
        }
        catch (AmazonS3Exception ex)
        {
            if (connection.ThrowExceptionOnErrorResponse)
                throw new UploadException(sw.ToString(), ex.Message, ex.InnerException);

            return new Result(
                false,
                result,
                connection.AuthenticationMethod is AuthenticationMethod.AWSCredentials ? sw.ToString() : $"Exception: {ex.Message}, InnerException: {ex.InnerException}"
                );
        }
        catch (Exception ex)
        {
            if (connection.ThrowExceptionOnErrorResponse)
                throw new UploadException(sw.ToString(), ex.Message, ex.InnerException);

            return new Result(
                false,
                result,
                connection.AuthenticationMethod is AuthenticationMethod.AWSCredentials ? sw.ToString() : $"Exception: {ex.Message}, InnerException: {ex.InnerException}"
                );
        }
        finally
        {
            // Back to defaults so that unit tests won't fail.
            AWSConfigs.LoggingConfig.LogTo = default;

            sw.Close();
            sw.Dispose();
        }
    }

    private static async Task UploadFilePreSignedUrl(Connection connection, string path, CancellationToken cancellationToken)
    {
        await using var fileStream = File.OpenRead(path);
        var fileStreamResponse = await new HttpClient().PutAsync(new Uri(connection.PreSignedURL), new StreamContent(fileStream), cancellationToken);
        var response = fileStreamResponse.EnsureSuccessStatusCode();
    }

    private static async Task<PutObjectResponse> UploadFileToS3(FileInfo file, Connection connection, string path, Input input, CancellationToken cancellationToken)
    {
        PutObjectResponse result;
        using (var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region)))
        {
            if (!connection.Overwrite)
            {
                try
                {
                    var request = new GetObjectRequest
                    {
                        BucketName = connection.BucketName,
                        Key = path,
                    };
                    await client.GetObjectAsync(request, cancellationToken);
                    throw new ArgumentException($"Object {file.Name} already exists in S3 at {request.Key}. Set Overwrite-option to true to overwrite the existing file.");
                }
                //Move on if AmazonS3Exception is thrown.
                catch (AmazonS3Exception) { }
            }

            var putObjectRequest = new PutObjectRequest
            {
                BucketName = connection.BucketName,
                Key = path,
                FilePath = file.FullName,
                CannedACL = (input.UseACL) ? GetS3CannedACL(input.ACL) : S3CannedACL.NoACL,
            };

            result = await client.PutObjectAsync(putObjectRequest, cancellationToken);
        };

        return result;
    }

    private static async Task UploadMultipart(FileInfo file, Connection connection, long partSize, string path, CancellationToken cancellationToken)
    {
        var uploadResponses = new List<UploadPartResponse>();

        InitiateMultipartUploadRequest initiateRequest = new()
        {
            BucketName = connection.BucketName,
            Key = path,
        };

        using var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region));
        var initResponse = await client.InitiateMultipartUploadAsync(initiateRequest, cancellationToken);

        long partSizeInBytes = partSize * (long)Math.Pow(2, 20);
        UploadPartRequest uploadRequest = null;
        try
        {
            long filePosition = 0;
            for (int i = 1; filePosition < file.Length; i++)
            {
                uploadRequest = new()
                {
                    BucketName = connection.BucketName,
                    Key = path,
                    UploadId = initResponse.UploadId,
                    PartNumber = i,
                    PartSize = partSizeInBytes,
                    FilePosition = filePosition,
                    FilePath = file.FullName,
                };

                uploadResponses.Add(await client.UploadPartAsync(uploadRequest, cancellationToken));

                filePosition += partSizeInBytes;
            }

            CompleteMultipartUploadRequest completeRequest = new()
            {
                BucketName = connection.BucketName,
                Key = path,
                UploadId = initResponse.UploadId
            };
            completeRequest.AddPartETags(uploadResponses);

            var completeUploadResponse = await client.CompleteMultipartUploadAsync(completeRequest, cancellationToken);
        }
        catch (Exception)
        {
            ListPartsRequest listPartsRequest = new()
            {
                UploadId = uploadRequest.UploadId
            };

            var listParts = await client.ListPartsAsync(listPartsRequest, cancellationToken);

            while (listParts.Parts.Count > 0)
            {
                foreach (var part in listParts.Parts)
                {
                    AbortMultipartUploadRequest abortMPURequest = new()
                    {
                        BucketName = connection.BucketName,
                        Key = path,
                        UploadId = uploadRequest.UploadId
                    };
                    await client.AbortMultipartUploadAsync(abortMPURequest, cancellationToken);
                }

                listParts = await client.ListPartsAsync(listPartsRequest, cancellationToken);
            }
        }
    }

    private static void DeleteSourceFile(string filePath)
    {
        try
        {
            var file = new FileInfo(filePath);
            while (IsFileLocked(file)) Thread.Sleep(1000);
            File.Delete(filePath);
        }
        catch (Exception ex) { throw new Exception($"Delete failed. ", ex); }
    }

    private static bool IsFileLocked(FileInfo file)
    {
        FileStream stream = null;

        try
        {
            stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None);
        }
        catch (IOException)
        {
            // The file is unavailable because it is:
            // 1. Still being written to.
            // 2. Being processed by another thread.
            // 3. Does not exist (has already been processed).
            return true;
        }
        finally { stream?.Close(); }

        // File is not locked.
        return false;
    }

    private static S3CannedACL GetS3CannedACL(ACLs acl)
    {
        return acl switch
        {
            ACLs.Private => S3CannedACL.Private,
            ACLs.PublicRead => S3CannedACL.PublicRead,
            ACLs.PublicReadWrite => S3CannedACL.PublicReadWrite,
            ACLs.AuthenticatedRead => S3CannedACL.AuthenticatedRead,
            ACLs.BucketOwnerRead => S3CannedACL.BucketOwnerRead,
            ACLs.BucketOwnerFullControl => S3CannedACL.BucketOwnerFullControl,
            ACLs.LogDeliveryWrite => S3CannedACL.LogDeliveryWrite,
            _ => S3CannedACL.NoACL,
        };
    }

    [ExcludeFromCodeCoverage(Justification = "Only able to test EU central 1.")]
    private static RegionEndpoint RegionSelection(Region region)
    {
        return region switch
        {
            Region.AfSouth1 => RegionEndpoint.AFSouth1,
            Region.ApEast1 => RegionEndpoint.APEast1,
            Region.ApNortheast1 => RegionEndpoint.APNortheast1,
            Region.ApNortheast2 => RegionEndpoint.APNortheast2,
            Region.ApNortheast3 => RegionEndpoint.APNortheast3,
            Region.ApSouth1 => RegionEndpoint.APSouth1,
            Region.ApSoutheast1 => RegionEndpoint.APSoutheast1,
            Region.ApSoutheast2 => RegionEndpoint.APSoutheast2,
            Region.CaCentral1 => RegionEndpoint.CACentral1,
            Region.CnNorth1 => RegionEndpoint.CNNorth1,
            Region.CnNorthWest1 => RegionEndpoint.CNNorthWest1,
            Region.EuCentral1 => RegionEndpoint.EUCentral1,
            Region.EuNorth1 => RegionEndpoint.EUNorth1,
            Region.EuSouth1 => RegionEndpoint.EUSouth1,
            Region.EuWest1 => RegionEndpoint.EUWest1,
            Region.EuWest2 => RegionEndpoint.EUWest2,
            Region.EuWest3 => RegionEndpoint.EUWest3,
            Region.MeSouth1 => RegionEndpoint.MESouth1,
            Region.SaEast1 => RegionEndpoint.SAEast1,
            Region.UsEast1 => RegionEndpoint.USEast1,
            Region.UsEast2 => RegionEndpoint.USEast2,
            Region.UsWest1 => RegionEndpoint.USWest1,
            Region.UsWest2 => RegionEndpoint.USWest2,
            _ => RegionEndpoint.EUWest1,
        };
    }
}
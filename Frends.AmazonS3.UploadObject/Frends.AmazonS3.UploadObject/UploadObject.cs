using Amazon;
using Amazon.S3;
using Amazon.S3.Model;
using Frends.AmazonS3.UploadObject.Definitions;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

namespace Frends.AmazonS3.UploadObject;

/// <summary>
/// Amazon S3 Task.
/// </summary>
public class AmazonS3
{
    /// <summary>
    /// Upload objects to AWS S3 Bucket.
    /// [Documentation](https://tasks.frends.com/tasks/frends-tasks/Frends.AmazonS3.UploadObject)
    /// </summary>
    /// <param name="connection">Connection parameters</param>
    /// <param name="input">Input parameters</param>
    /// <param name="cancellationToken">Token generated by Frends to stop this Task.</param>
    /// <returns>Object { bool success, List&lt;string&gt; uploadedObjects, string debugLog } </returns>
    public static async Task<Result> UploadObject([PropertyTab] Connection connection, [PropertyTab] Input input, CancellationToken cancellationToken)
    {

        if (!Directory.Exists(input.FilePath)) throw new ArgumentException(@"Source directory not found. ", input.FilePath);
        if (!Directory.EnumerateFileSystemEntries(input.FilePath).Any()) throw new ArgumentException(@"Directory is empty.", input.FilePath);

        var localRoot = new DirectoryInfo(input.FilePath);

        // If filemask is not set, get all files.
        var filesToCopy = localRoot.GetFiles(
            input.FileMask ?? "*",
            connection.UploadFromCurrentDirectoryOnly ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories);

        if (connection.ThrowErrorIfNoMatch && filesToCopy.Length < 1)
            throw new Exception($"No files match the filemask '{input.FileMask}' within supplied path.");

        var result = new List<string>();
        var sw = new StringWriter();

        try
        {
            AWSConfigs.LoggingConfig.LogTo = LoggingOptions.Console;
            Console.SetOut(sw);

            foreach (var file in filesToCopy)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (file.FullName.Split(Path.DirectorySeparatorChar).Length > input.FilePath.Split(Path.DirectorySeparatorChar).Length && connection.PreserveFolderStructure)
                {
                    var subfolders = file.FullName.Replace(file.Name, "").Replace(input.FilePath.Replace(file.Name, ""), "").Replace(Path.DirectorySeparatorChar, '/');

                    if (subfolders.StartsWith("/"))
                        subfolders = subfolders.Remove(0, 1);

                    var fullPath = input.S3Directory + subfolders + file.Name;

                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedURL)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input.PartSize, fullPath, cancellationToken);
                        else
                            await UploadFileToS3(file, connection, fullPath, input, cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? fullPath : file.FullName);
                }
                else
                {
                    if (connection.AuthenticationMethod is AuthenticationMethod.PreSignedURL)
                        await UploadFilePreSignedUrl(connection, file.FullName, cancellationToken);
                    else
                    {
                        if (connection.UseMultipartUpload)
                            await UploadMultipart(file, connection, input.PartSize, input.S3Directory + file.Name, cancellationToken);
                        else
                            await UploadFileToS3(file, connection, input.S3Directory + file.Name, input, cancellationToken);
                    }

                    result.Add(connection.ReturnListOfObjectKeys ? input.S3Directory + file.Name : file.FullName);
                }

                if (connection.DeleteSource) DeleteSourceFile(file.FullName);

                // Each file require their own presigned URL so no point to loop more than first file.
                if (connection.AuthenticationMethod == AuthenticationMethod.PreSignedURL) break;
            }

            return new Result(true, result, sw.ToString());
        }
        catch (AmazonS3Exception ex)
        {
            if (connection.ThrowExceptionOnErrorResponse)
                throw new UploadException(sw.ToString(), ex.Message, ex.InnerException);

            return new Result(
                false,
                result,
                connection.AuthenticationMethod is AuthenticationMethod.AWSCredentials ? sw.ToString() : $"Exception: {ex.Message}, InnerException: {ex.InnerException}"
                );
        }
        catch (Exception ex)
        {
            if (connection.ThrowExceptionOnErrorResponse)
                throw new UploadException(sw.ToString(), ex.Message, ex.InnerException);

            return new Result(
                false,
                result,
                connection.AuthenticationMethod is AuthenticationMethod.AWSCredentials ? sw.ToString() : $"Exception: {ex.Message}, InnerException: {ex.InnerException}"
                );
        }
        finally
        {
            // Back to defaults so that unit tests won't fail.
            AWSConfigs.LoggingConfig.LogTo = default;

            sw.Close();
            sw.Dispose();
        }
    }

    private static async Task UploadFilePreSignedUrl(Connection connection, string path, CancellationToken cancellationToken)
    {
        await using var fileStream = File.OpenRead(path);
        var fileStreamResponse = await new HttpClient().PutAsync(new Uri(connection.PreSignedURL), new StreamContent(fileStream), cancellationToken);
        var response = fileStreamResponse.EnsureSuccessStatusCode();
    }

    private static async Task<PutObjectResponse> UploadFileToS3(FileInfo file, Connection connection, string path, Input input, CancellationToken cancellationToken)
    {
        PutObjectResponse result;
        using (var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region)))
        {
            if (!connection.Overwrite)
            {
                try
                {
                    var request = new GetObjectRequest
                    {
                        BucketName = connection.BucketName,
                        Key = path,
                    };
                    await client.GetObjectAsync(request, cancellationToken);
                    throw new ArgumentException($"Object {file.Name} already exists in S3 at {request.Key}. Set Overwrite-option to true to overwrite the existing file.");
                }
                //Move on if AmazonS3Exception is thrown.
                catch (AmazonS3Exception) { }
            }

            var putObjectRequest = new PutObjectRequest
            {
                BucketName = connection.BucketName,
                Key = path,
                FilePath = file.FullName,
                CannedACL = (input.UseACL) ? GetS3CannedACL(input.ACL) : S3CannedACL.NoACL,
            };

            result = await client.PutObjectAsync(putObjectRequest, cancellationToken);
        };

        return result;
    }

    private static async Task UploadMultipart(FileInfo file, Connection connection, long partSize, string path, CancellationToken cancellationToken)
    {
        // Create list to store upload part responses.
        var uploadResponses = new List<UploadPartResponse>();

        // Setup information required to initiate the multipart upload.
        InitiateMultipartUploadRequest initiateRequest = new()
        {
            BucketName = connection.BucketName,
            Key = path,
        };

        using (var client = new AmazonS3Client(connection.AwsAccessKeyId, connection.AwsSecretAccessKey, RegionSelection(connection.Region)))
        {
            var initResponse = await client.InitiateMultipartUploadAsync(initiateRequest, cancellationToken);

            long partSizeInBytes = partSize * (long)Math.Pow(2, 20);

            try
            {
                long filePosition = 0;
                for (int i = 1; filePosition < file.Length; i++)
                {
                    UploadPartRequest uploadRequest = new()
                    {
                        BucketName = connection.BucketName,
                        Key = path,
                        UploadId = initResponse.UploadId,
                        PartNumber = i,
                        PartSize = partSizeInBytes,
                        FilePosition = filePosition,
                        FilePath = file.FullName,
                    };

                    // Upload a part and add the response to our list.
                    uploadResponses.Add(await client.UploadPartAsync(uploadRequest, cancellationToken));

                    filePosition += partSizeInBytes;
                }

                // Setup to complete the upload.
                CompleteMultipartUploadRequest completeRequest = new()
                {
                    BucketName = connection.BucketName,
                    Key = path,
                    UploadId = initResponse.UploadId
                };
                completeRequest.AddPartETags(uploadResponses);

                // Complete the upload.
                var completeUploadResponse = await client.CompleteMultipartUploadAsync(completeRequest, cancellationToken);
            }
            catch (Exception ex)
            {
                // Abort the upload.
                AbortMultipartUploadRequest abortMPURequest = new()
                {
                    BucketName = connection.BucketName,
                    Key = path,
                    UploadId = initResponse.UploadId
                };
                await client.AbortMultipartUploadAsync(abortMPURequest, cancellationToken);
            }
        }
    }

    private static void DeleteSourceFile(string filePath)
    {
        try
        {
            var file = new FileInfo(filePath);
            while (IsFileLocked(file)) Thread.Sleep(1000);
            File.Delete(filePath);
        }
        catch (Exception ex) { throw new Exception($"Delete failed. ", ex); }
    }

    private static bool IsFileLocked(FileInfo file)
    {
        FileStream stream = null;

        try
        {
            stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None);
        }
        catch (IOException)
        {
            // The file is unavailable because it is:
            // 1. Still being written to.
            // 2. Being processed by another thread.
            // 3. Does not exist (has already been processed).
            return true;
        }
        finally { stream?.Close(); }

        // File is not locked.
        return false;
    }

    private static S3CannedACL GetS3CannedACL(ACLs acl)
    {
        return acl switch
        {
            ACLs.Private => S3CannedACL.Private,
            ACLs.PublicRead => S3CannedACL.PublicRead,
            ACLs.PublicReadWrite => S3CannedACL.PublicReadWrite,
            ACLs.AuthenticatedRead => S3CannedACL.AuthenticatedRead,
            ACLs.BucketOwnerRead => S3CannedACL.BucketOwnerRead,
            ACLs.BucketOwnerFullControl => S3CannedACL.BucketOwnerFullControl,
            ACLs.LogDeliveryWrite => S3CannedACL.LogDeliveryWrite,
            _ => S3CannedACL.NoACL,
        };
    }

    private static RegionEndpoint RegionSelection(Region region)
    {
        return region switch
        {
            Region.AfSouth1 => RegionEndpoint.AFSouth1,
            Region.ApEast1 => RegionEndpoint.APEast1,
            Region.ApNortheast1 => RegionEndpoint.APNortheast1,
            Region.ApNortheast2 => RegionEndpoint.APNortheast2,
            Region.ApNortheast3 => RegionEndpoint.APNortheast3,
            Region.ApSouth1 => RegionEndpoint.APSouth1,
            Region.ApSoutheast1 => RegionEndpoint.APSoutheast1,
            Region.ApSoutheast2 => RegionEndpoint.APSoutheast2,
            Region.CaCentral1 => RegionEndpoint.CACentral1,
            Region.CnNorth1 => RegionEndpoint.CNNorth1,
            Region.CnNorthWest1 => RegionEndpoint.CNNorthWest1,
            Region.EuCentral1 => RegionEndpoint.EUCentral1,
            Region.EuNorth1 => RegionEndpoint.EUNorth1,
            Region.EuSouth1 => RegionEndpoint.EUSouth1,
            Region.EuWest1 => RegionEndpoint.EUWest1,
            Region.EuWest2 => RegionEndpoint.EUWest2,
            Region.EuWest3 => RegionEndpoint.EUWest3,
            Region.MeSouth1 => RegionEndpoint.MESouth1,
            Region.SaEast1 => RegionEndpoint.SAEast1,
            Region.UsEast1 => RegionEndpoint.USEast1,
            Region.UsEast2 => RegionEndpoint.USEast2,
            Region.UsWest1 => RegionEndpoint.USWest1,
            Region.UsWest2 => RegionEndpoint.USWest2,
            _ => RegionEndpoint.EUWest1,
        };
    }
}